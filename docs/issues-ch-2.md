# [CH-2] 세션 히스토리 로드 및 컨텍스트 캐시(최근 20개)

## Problem 1-Pager
- 배경: WebSocket 채팅이 도입됐지만 페이지 재진입 시 매번 새 세션이 생성되어 이전 대화를 볼 수 없고, 컨텍스트도 재구성되어 UX/비용이 낭비된다.
- 문제: (1) 프론트가 세션 ID를 유지하지 않아 히스토리가 초기화됨, (2) 초기 메시지 로드 없이 빈 화면에서 시작, (3) 컨텍스트 캐시가 있어도 활용되지 않아 매 요청 DB 조회가 반복, (4) 히스토리 제한(최근 20개) 기준이 클라이언트에 반영되지 않음.
- 목표: 동일 인사이트 재접속 시 마지막 20개 메시지를 즉시 표시하고, 컨텍스트 캐시를 활용해 WebSocket 첫 응답을 빠르게 만든다.
- 비목표: SSE 폴백/연결 상태 UI(별도 CH-3), 인증/권한, 다중 기기 동기화, 백엔드 세션 검색 API 신설.
- 제약: 파일≤300LOC·함수≤50LOC, 최근 20개 한정 표시, 비용 상한(요청당 $0.02) 준수, 민감정보 로깅 금지, 새 코드에 테스트 추가.

## 대안 비교
- Option A: 클라이언트 로컬 저장(localStorage)로 기존 세션 재사용 + REST 초기 히스토리 로드  
  - 장점: 서버 변경 최소, 구현 단순, 오프라인/리로드 친화.  
  - 단점/위험: 클라이언트 캐시 삭제 시 세션 분리, 다중 기기 간 공유 불가.
- Option B: 서버에서 사용자+인사이트별 최신 세션 조회/재사용 API 추가  
  - 장점: 단일 소스, 기기 간 일관성.  
  - 단점/위험: API 추가/쿼리 복잡도 증가, 인증 미도입 상태에서 사용자 구분 한계.  
  - 선택: **Option A** 우선, Option B는 인증 도입 후 검토.

## 범위/비범위
- 포함: 세션 ID 로컬 보존, 초기 메시지(최근 20개) 로드, WebSocket 훅에서 히스토리 머지, 컨텍스트 캐시 활용/리밋 보장, 회귀 테스트 추가.
- 제외: SSE 폴백, 세션 검색 API, 알림/Slack 연동, 다중 기기 동기화.

## 수용 기준
- 동일 인사이트 재접속 시 마지막 20개 메시지가 즉시 표시된다(REST 초기 로드).
- WebSocket 재연결 후 신규 메시지가 이어서 스트리밍되며 중복/유실이 없다.
- 컨텍스트는 리포트 요약 + 최근 20개 메시지로 구성되고 캐시를 사용한다.

## 테스트
- 단위: ChatService 컨텍스트가 최근 20개만 포함/캐시에 반영, 스트림 후 캐시 업데이트. 훅/세션 보존은 통합/E2E로 커버.
- 통합: WebSocket 흐름 + 초기 메시지 로드 병행(수동/Playwright는 후속 CH-3와 함께 검토).

## 리스크/의존성
- localStorage 비우면 새 세션이 생겨 히스토리 단절 → 안내 문구/자동 생성 허용.
- Redis 미가동 시 캐시 효과 감소 → DB 조회 폴백 이미 존재.
- 중복 메시지 가능성(초기 히스토리 + 스트림) → ID 기반 머지 로직으로 방지 필요.
