# 서버 실행/종료 스크립트 PLAN

## Problem 1-Pager
- 배경: StockTeacher는 FastAPI 기반 웹 API(`api.main:app`)와 Next.js 웹 프론트(`web/`)를 동시에 구동해야 웹에서 리포트를 확인할 수 있다. 현재 README에는 수동 실행 명령만 있고, 개발자가 매번 긴 명령을 기억하고 두 개의 터미널을 직접 관리해야 한다.
- 문제: API/웹 서버 실행 절차가 반복적이고 사람마다 다르게 수행될 수 있어, 환경 변수 설정 누락·포트 충돌·백그라운드 프로세스 잔존 등의 실수가 발생한다. 특히 “올리고/내리는” 공통 패턴이 문서화/자동화되어 있지 않다.
- 목표: 로컬 개발자가 `scripts/run_servers.sh` 한 번으로 API/웹 서버를 올리고, `scripts/stop_servers.sh` 한 번으로 관련 프로세스를 안전하게 종료할 수 있도록 간단한 스크립트를 제공한다. Python/Node 버전이나 uv 사용 여부에 의존하지 않고, 현재 프로젝트 구조에 맞는 기본값을 사용한다.
- 비목표: Celery Beat/Worker, Redis/Postgres 컨테이너, 분석 파이프라인까지 모두 포함한 “풀 스택” 오케스트레이터를 만드는 것은 이번 범위가 아니다. 또한 프로덕션용 systemd 서비스나 Docker Compose 기반 앱 전체 실행 스크립트는 다루지 않는다.
- 제약: 스크립트는 1파일당 300 LOC 이하, 함수/블록은 50 LOC 이하로 유지한다. 민감 값(.env 내용 등)을 에코하거나 로그에 남기지 않는다. bash에 의존하되, macOS/Linux 환경에서 기본 제공되는 도구(ps, grep, sed 등)만 사용하고 추가 설치를 요구하지 않는다.

## 대안 비교
- Option A: 단순 셸 스크립트로 uvicorn/Next dev를 백그라운드 실행 후 PID 파일로 관리
  - 장점: 의존성이 거의 없고, 현재 README의 수동 명령을 그대로 래핑할 수 있다.
  - 단점: 로깅/재시작/에러 핸들링이 거칠고, 셸 구현 차이에 따라 ps/grep 동작이 다를 수 있다.
  - 위험: PID 파일이 오래되거나 충돌할 경우 잘못된 프로세스를 종료할 가능성이 있다.
- Option B: Python 관리 스크립트(예: scripts/manage.py)에서 subprocess로 uvicorn/Next를 실행
  - 장점: 에러 처리, 경로 제어, 로그 출력 등을 Python에서 더 정교하게 다룰 수 있다.
  - 단점: Python 모듈 경로/가상환경 경로 문제 등으로 셸 한 줄 실행보다 복잡해진다.
  - 위험: uv/venv 조합, PATH 설정 차이로 인해 개발자마다 동작이 달라질 수 있다.

**선택**: Option A를 우선 채택한다. README에 이미 uv/uvicorn/Next 실행 명령이 정의되어 있어 이를 thin wrapper로 제공하는 것이 가장 단순하다. PID 파일은 프로젝트 루트의 `var/pids` 디렉터리 아래에 두어 충돌 가능성을 최소화하고, stop 스크립트에서 존재/실행 여부를 검증한 뒤 종료하도록 방어 로직을 추가한다.

