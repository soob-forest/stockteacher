# 웹 애플리케이션 단계 구현 계획

## 1. 배경 및 목표
- `docs/SPEC.md`에서 정의한 대로 리포트 소비 채널을 웹 포털로 전환해 사용자가 종목 구독 관리, 리포트 열람, 에이전트와의 대화를 단일 인터페이스에서 수행할 수 있도록 한다.
- 수집/분석 파이프라인이 생성한 `ProcessedInsight`를 웹 전용 뷰 모델로 가공해 10분 이내로 게시하고, 리포트 열람 후 대화 전환율 30% 달성을 지원한다.

## 2. 범위 및 비범위
- **범위**
  - 웹 프론트엔드(React/Next.js) 화면: 구독 관리, 리포트 목록/상세, 에이전트 채팅 패널
  - 웹 백엔드(API): 인증/인가, 리포트 조회, 종목 구독 CRUD, 채팅 세션/메시지 브로커
  - publish 단계와의 연동: 뷰 모델/캐시 생성, SLA 모니터링 지표 수집
  - 채팅 에이전트와의 인터페이스(OpenAI Assistants 또는 Responses API)
- **비범위**
  - 데이터 수집·분석 파이프라인 로직 변경
  - 추가 알림 채널(이메일, 푸시) 구현
  - 고급 관리자 콘솔/대시보드 고도화

## 3. 주요 요구 요약
- 사용자는 종목을 검색해 구독/해지하고 알림 창(`alert_window`)을 설정할 수 있어야 한다.
- 리포트 목록은 감성 태그/날짜 필터/즐겨찾기 기능을 제공하며, 상세 페이지는 요약 블록, 감성 ASCII 게이지, 원문 링크, 관련 아티팩트 뷰어를 포함한다.
- 대화형 에이전트 패널은 현재 리포트 컨텍스트를 유지한 채 WebSocket/SSE를 통해 스트리밍 응답을 제공한다.
- 관리자 권한 사용자는 실패 리포트 재게시, Dead-letter 큐 항목 확인 등의 기본 운영 기능을 사용할 수 있어야 한다(SHOULD).

## 4. 기술 및 아키텍처 개요
- **프론트엔드**: Next.js(App Router) + TypeScript, Zustand/Redux Toolkit으로 상태 관리, Tailwind 또는 Chakra UI로 컴포넌트 구성, WebSocket/SSE 클라이언트 내장.
- **백엔드 API**: Python FastAPI 또는 Kotlin Spring Boot (MVP는 FastAPI 가정), PostgreSQL + Redis 연동, OAuth2 기반 인증, OpenTelemetry로 추적.
- **채팅 에이전트**: OpenAI Assistants/Responses API 연동, Redis에 세션 컨텍스트 캐시, 장기 메시지는 ChatMessage 테이블에 저장.
- **배포**: Web은 Vercel/Static Hosting(SSR 필요 시 Next.js 서버), API는 Docker 이미지로 ECS/Fargate 또는 Cloud Run 배포, CI/CD는 GitHub Actions.
- **관찰성**: Prometheus/CloudWatch 메트릭(페이지 로드, API latency, 채팅 전환율), Log aggregation(구조화 JSON), SLA 위반 알림 PagerDuty/Slack Ops.

## 5. 구현 체크리스트
- ### 프론트엔드
  - [ ] 디자인 시스템 및 UI 프레임워크 선정, 전역 스타일 가이드 마련
  - [ ] 구독 관리 페이지 컴포넌트 구현 (검색, 등록/해지, 알림 설정 폼)
  - [ ] 리포트 목록 화면 구현 (필터, 감성 태그, 즐겨찾기)
  - [ ] 리포트 상세 화면 구현 (요약 블록, 감성 ASCII, 링크, 아티팩트 뷰어)
  - [ ] 에이전트 채팅 패널 구현 (스트리밍 응답, 컨텍스트 표시, 오류 핸들링)
  - [ ] 인증 흐름 구현 (로그인, 세션 갱신, 권한 처리)
  - [ ] 접근성 및 반응형 레이아웃 검증

- ### 백엔드/API
  - [ ] OAuth2/SSO 연동 및 사용자/권한 모델 정의
  - [ ] 구독 CRUD 및 알림 설정 API 구현 (`StockSubscription` 연계)
  - [ ] 리포트 조회 API 구현 (목록, 상세, 검색/필터링)
  - [ ] publish 단계 뷰 모델 캐시 리더/생성기 구현 (`ProcessedInsight` → DTO)
  - [ ] 채팅 세션/메시지 API 및 WebSocket/SSE 엔드포인트 구현
  - [ ] 관리자용 운영 API (재게시, Dead-letter 조회) 설계 및 초기 구현
  - [ ] OpenTelemetry/메트릭/구조화 로그 설정

- ### 채팅 에이전트 연동
  - [ ] 프롬프트/툴링 전략 정의 (리포트 컨텍스트 삽입, 금칙어, Guardrail)
  - [ ] OpenAI Assistants/Responses API 클라이언트 래퍼 구현
  - [ ] 세션 컨텍스트 캐시( Redis ) 및 청소 전략 구현
  - [ ] 실패/오류 케이스 핸들링 및 재시도 정책 수립

- ### 데이터/스토리지
  - [ ] `report_snapshot`(또는 ProcessedInsight 파생 뷰) 스키마 확정
  - [ ] 아티팩트 호스팅(이미지/PDF) 및 접근 제어 설계
  - [ ] 즐겨찾기/읽음 상태 메타데이터 저장 구조 정의
  - [ ] 데이터 보존 및 삭제 정책 정리 (GDPR/국내 규제 대응)

- ### 테스트 및 품질
  - [ ] 프론트엔드 단위/스토리북/시각 회귀 테스트 구성
  - [ ] API 단위/통합 테스트 (FastAPI + pytest 또는 Spring + JUnit)
  - [ ] 채팅 에이전트 회귀 테스트(모킹 프레임워크로 시나리오별 검증)
  - [ ] SLA 검증용 엔드투엔드 시나리오 (수집 완료 → 게시 → 열람 → 대화)
  - [ ] 성능/부하 테스트 계획 수립 (리포트 조회, 채팅 동시 접속)

- ### 운영 및 배포
  - [ ] CI/CD 파이프라인 설계 (테스트, 빌드, 배포 단계)
  - [ ] 환경 변수/비밀 관리(.env 템플릿, KMS/Secrets Manager)
  - [ ] 모니터링 대시보드 구성 (리포트 게시율, 응답 시간, 전환율)
  - [ ] 롤백/피처 플래그 전략 수립
  - [ ] 사용자 온보딩/헬프 문서 초안 작성

## 6. 리스크 및 완화 전략
- **LLM 응답 품질 저하**: 사전 정의된 평가 프롬프트와 샘플 테스트를 자동화하고, 응답에 금칙어/PII 필터 적용.
- **실시간 채팅 지연**: 스트리밍 응답, Redis 캐시 튜닝, 백프레셔 방식 마련.
- **대용량 리포트 렌더링 성능**: Lazy loading과 캐시 계층(Edge Cache) 도입, 이미지 최적화.

## 7. 검증 및 출시 전략
- [ ] 내부 베타 (사내 사용자) 대상 피드백 수집
- [ ] KPI 모니터링(게시 시간, 대화 전환율) 자동 리포트 구성
- [ ] 사용자 지원 채널(FAQ/티켓 시스템) 마련
- [ ] 정식 출시 전 접근성/보안 점검 체크 완료
